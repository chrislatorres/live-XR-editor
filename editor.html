<!doctype html>
<html>
<body>
<canvas id=canvas></canvas>
<div id=container></div>
<script src="js/three.js"></script>
<script src="js/ScreenQuad.js"></script>
<script src="js/keycode.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script>
(() => {

  const container = document.getElementById('container');
  const canvas = document.getElementById('canvas');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;


  const width = 2048;
  const height = 2048;
  const DEFAULT_USER_HEIGHT = 1.6;
  const FLOOR_SIZE = 20;



  function getQueryParameter(name) {
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp("[?&]" + name + '(=([^&#]*)|&|#|$)'),
       results = regex.exec(window.location.href);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
  }

  const renderer = new THREE.WebGLRenderer({
    canvas,
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.sortObjects = false;
  renderer.vr.enabled = true;

  let camera, scene, mrenderer, controls, browserPlane,
    ecanvas, ctx, texture, browserWindow,
    mouse = new THREE.Vector2(),
    raycaster = new THREE.Raycaster();

  init();
  animate();

  function init() {
    setupScene();
    setupCanvasAndTexture();
    setupElectron()
      .then(()=>{
        setupBrowserPlane();
        setupListeners();
      });
  }

  async function setupElectron(){
    const elctrn = await browser.electron.createElectron();
    browserWindow = await elctrn.createBrowserWindow({
      width,
      height,
      show: false,
      frame: false,
      webPreferences: {
        offscreen: true,
        transparent: true,
      },
    });
    ecanvas.width = browserWindow.width;
    ecanvas.height = browserWindow.height;

    browserWindow.loadURL('http://localhost:3000/');
    browserWindow.setFrameRate(60);

    browserWindow.on('paint', o => {
      ctx.putImageData(new ImageData(o.data, o.width, o.height), o.x, o.y );
      texture.needsUpdate = true;
    });
    browserWindow.on('dom-ready', async () => {
      console.log('dom-ready');
      await browserWindow.insertCSS(`
                ::-webkit-scrollbar {
                  height: 30px;
                  width: 30px;
                  background: #e0e0e0;
                }

                ::-webkit-scrollbar-thumb {
                  background: #4db6ac;
                }

                ::-webkit-scrollbar-corner {
                  background: #cfcfcf;
                }
              `);
      //texture.needsUpdate = true;
    });
    browserWindow.on('did-fail-load', () => {
      console.log('failed to load!');

      // browserWindow.destroy();
      // elctrn.destroy();
    });
  }

  function setupBrowserPlane(){

    // Setup plane mesh to display canvas
    let geometry = new THREE.PlaneBufferGeometry( 1, browserWindow.height/browserWindow.width );
    let material = new THREE.MeshBasicMaterial( {
      map: texture,
      side: THREE.DoubleSide,
    } );
    browserPlane = new THREE.Mesh( geometry, material );
    scene.add( browserPlane );
  }

  function setupScene(){

    // Setup Camera
    const upVector = new THREE.Vector3(0, 1, 0);
    const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));
    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localVector3 = new THREE.Vector3();
    const localVector4 = new THREE.Vector3();
    const localVector5 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localQuaternion2 = new THREE.Quaternion();
    const localEuler = new THREE.Euler();
    localEuler.order = 'YXZ';
    const localEuler2 = new THREE.Euler();
    localEuler2.order = localEuler.order;
    const localMatrix = new THREE.Matrix4();
    const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10 * 1024);
    camera.position.set(0, DEFAULT_USER_HEIGHT, 1);
    camera.rotation.order = 'YXZ';

    // Setup Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x7E57C2);

    // Setup Renderer
    mrenderer = new THREE.WebGLRenderer( { antialias: true } );
    mrenderer.setPixelRatio( window.devicePixelRatio );
    mrenderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( mrenderer.domElement );


    // Register resize events to handle renderer and camera update
    window.addEventListener( 'resize', onWindowResize, false );
  }

  function setupCanvasAndTexture(){

    // Setup canvas and texture
    ecanvas = document.createElement('canvas');
    ecanvas.width = width;
    ecanvas.height = height;
    ctx = ecanvas.getContext('2d');
    texture = new THREE.Texture(
      ecanvas/*,
            THREE.UVMapping,
            THREE.ClampToEdgeWrapping,
            THREE.ClampToEdgeWrapping,
            THREE.LinearMipMapNearestFilter,
            THREE.LinearMipMapNearestFilter,
            THREE.RGBAFormat,
            THREE.UnsignedByteType,
            1*/
    );
  }

  function mouseEvent(type,e){
    if(type==="mousewheel"){
      let localMouse = {
        x:0,
        y:0,

      };

      // Store the delta for mousewheel events.
      localMouse.deltaY = e.deltaY;
      localMouse.deltaX = e.deltaX;
      return sendMouseEvent(type,e,localMouse);
    }

    // Get normalised mouse coordinates
    mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
    raycaster.setFromCamera( mouse, camera );

    let intersects = raycaster.intersectObjects( scene.children );
    let localMouse;
    if(intersects.length&&intersects[0].object === browserPlane){

      // Convert the intersection point from world to local coordinates.
      let localPoint = browserPlane.worldToLocal(intersects[0].point);
      let planeHeight = browserWindow.height/browserWindow.width;
      localMouse = {
        x:((localPoint.x+0.5)/1)*browserWindow.width,
        // Invert the Y coordinate for top down orientation of the browser coordinates.
        y:browserWindow.height-(((planeHeight/2+localPoint.y)/planeHeight)*browserWindow.height)
      };

      //Pause the orbit controls for mousemove events in betweenmousedown and mouseup
      if(type==='mousedown'){
        //controls.enabled = false;
      }
      if(type==='mouseup'){
        //controls.enabled = true;
      }
      sendMouseEvent(type,e,localMouse);
    }
  }

  function sendMouseEvent(type,e,mouse){
    let _event;
    let _button;
    if(e.detail){
      // Convert the mouse button value to a string for electron webcontents.
      switch(e.detail.button){
        case 0:
          _button = 'left';
          break;
        case 1:
          _button = 'middle';
          break;
        case 2:
          _button = 'right';
          break;
      }
    }
    switch(type){
      case 'mousemove':
      case 'mouseup':
      case 'mousedown':
        // Set minimum options for mouse events.
        _event = {
          type:type,
          x:mouse.x,
          y:mouse.y,
          button:_button||'left',
          globalX:mouse.x,
          globalY:mouse.y,
          movementX:0,
          movementY:0,
          clickCount:1
        };
        break;
      case 'mousewheel':
        // Set minimum options for mousewheel events.
        _event = {
          type:type,
          x:mouse.x,
          y:mouse.y,
          button:3,
          globalX:mouse.x,
          globalY:mouse.y,
          movementX:0,
          movementY:0,
          clickCount:1,
          deltaX:-mouse.deltaX,
          deltaY:-mouse.deltaY,
          wheelTicksX:0,
          wheelTicksY:0,
          accelerationRatioX:1,
          accelerationRatioY:1,
          hasPreciseScrollingDeltas:true,
          canScroll:true
        };
        break;
    }
    if(_event){
      // Send the event to electron over IPC.
      browserWindow.sendInputEvent(_event);
    }
  }

  function mousemove(e){
    mouseEvent('mousemove',e);
  }

  function mousedown(e){
    mouseEvent('mousedown',e);
  }

  function mouseup(e){
    mouseEvent('mouseup',e);
  }

  function mousewheel(e){
    mouseEvent('mousewheel',e);
  }

  function keyup(e){
    keyEvent('keyup',e);
  }

  function keydown(e){
    keyEvent('keyup',e);
  }

  function keyEvent(type,e){
    // Setup modifiers array and populate form the key events.
    let modifiers = [];
    if(e.ctrlKey){
      modifiers.push('control');
    }
    if(e.altKey){
      modifiers.push('alt');
    }
    if(e.metaKey){
      modifiers.push('meta');
    }
    if(e.shiftKey){
      modifiers.push('shift');
    }
    if(e.repeat){
      modifiers.push('isAutoRepeat');
    }
    browserWindow.sendInputEvent({
      type:type,
      keyCode:e.key,
      modifiers:modifiers
    });
    // If is an alphanumeric key then send the char event also to get the text to show up in the input fields
    // Do not send if this is a modified keypress i.e. Ctrl+A, Ctrl+V
    if (e.which <= 90 && e.which >= 48&&type==="keyup"&&!modifiers.length){
      browserWindow.sendInputEvent({
        type:'char',
        keyCode:e.key
      });
    }
  }

  function setupListeners(){

    // Register keyboard and mouse event listeners
    document.addEventListener( 'mousemove', mousemove, false );
    document.addEventListener( 'mousedown', mousedown, false );
    document.addEventListener( 'mouseup', mouseup, false );
    document.addEventListener( 'wheel', mousewheel, false);
    document.addEventListener( 'keyup', keyup, false);
    document.addEventListener( 'keydown', keydown, false);
  }


    const _submitUrl = u => {
      currentApps = [u];
      _updateLocalApps();
      }

    const _makeRenderTarget = (width, height) => {
      const renderTarget = new THREE.WebGLRenderTarget(width, height);
      renderTarget.depthTexture = new THREE.DepthTexture(
        width,
        height,
        THREE.UnsignedInt248Type,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        1,
        THREE.DepthStencilFormat
      );
      return renderTarget;
    };
    let renderTarget = _makeRenderTarget(canvas.width, canvas.height);

    const floorMesh = (() => {
      const geometry = new THREE.PlaneBufferGeometry(FLOOR_SIZE, FLOOR_SIZE)
        .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
          new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 1, 0)
          )
        ));
      const uvs = geometry.attributes.uv.array;
      const numUvs = uvs.length / 2;
      for (let i = 0; i < numUvs; i++) {
        uvs[i * 2] *= FLOOR_SIZE / 10 * 2;
        uvs[i * 2 + 1] *= FLOOR_SIZE / 10;
      }
      const texture = new THREE.Texture(
        null,
        THREE.UVMapping,
        THREE.RepeatWrapping,
        THREE.RepeatWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
      });
      const mesh = new THREE.Mesh(geometry, material);
      // mesh.visible = false;
      return mesh;
    })();
    scene.add(floorMesh);

    const skyboxMesh = (() => {
      const vertexShader = [
        'varying vec3 vWorldPosition;',
        'void main() {',
          'vec4 worldPosition = modelMatrix * vec4( position, 1.0 );',
          'vWorldPosition = worldPosition.xyz;',
          'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}'
      ].join('\n');
      const fragmentShader = [
        'vec3 colorTop = vec3(33.0/256.0, 33.0/256.0, 33.0/256.0);',
        'vec3 colorBottom = vec3(11.0/256.0, 11.0/256.0, 11.0/256.0);',
        'varying vec3 vWorldPosition;',
        'void main() {',
          'vec3 pointOnSphere = normalize(vWorldPosition.xyz);',
          'float f = 1.0;',
          'if (pointOnSphere.y > - 0.2){',
            'f = sin(pointOnSphere.y * 2.0);',
          '}',
          'gl_FragColor = vec4(mix(colorBottom,colorTop, f ), 1.0);',
        '}'
      ].join('\n');
      const mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1000, 1000, 1000), new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        side: THREE.BackSide,
      }));
      return mesh;
    })();
    scene.add(skyboxMesh);

    const compositeScene = new THREE.Scene();
    const screenQuad = new ScreenQuad({
      texture1: renderTarget.texture,
      depth1: renderTarget.depthTexture,
    });
    let framebuffer = null;
    compositeScene.add(screenQuad);
    const position = new THREE.Vector3();
    const velocity = new THREE.Vector3();
    const speed = 0.0001;
    let lastTime = Date.now();

    const _render = () => {
      if (framebuffer) {
        framebuffer.render();
      }
      const device = renderer.vr.getDevice();
      if (device && device.constructor.name === 'FakeVRDisplay') {
        camera.position.copy(device.position);
        camera.quaternion.copy(device.quaternion);
        renderer.render(scene, camera, renderTarget);
      } else {
        renderer.render(scene, camera, renderTarget);
      }
      renderer.vr.enabled = false;
      renderer.render(compositeScene, camera);
      renderer.vr.enabled = true;
    };

    let iframes = [];
    const _openUrl = u => {
      const _drawOk = () => {
        console.log('Load ok: ' + u);
      };
      const _drawFail = () => {
        console.log('Load error: ' + u);
      };
      const iframe = document.createElement('iframe');
      iframe.onload = function() {
        const contentDocument = (() => {
          try {
            if (this.contentDocument) { // this potentially throws
              return this.contentDocument;
            } else {
              return null;
            }
          } catch(err) {
            console.warn(err.stack);
            return null;
          }
        })();
        if (contentDocument) {
          _drawOk();
          if (contentDocument.resources) {
            iframeResources = iframe.contentWindow.document.resources;
            resources.push(iframeResources);
            iframeResources.addEventListener('update', _resourcesUpdate);
          }
          floorMesh.visible = false;
          skyboxMesh.visible = false;
          scene.background = null;
        } else {
          _closeUrl(iframe);
          iframes.splice(iframes.indexOf(iframe), 1);
          const index = currentApps.indexOf(iframe.src);
          if (index !== -1) {
            currentApps.splice(index, 1);
          }
          _drawFail();
        }
      };
      iframe.src = u;
      iframe.hidden = true;
      let iframeResources = null;
      iframe.addEventListener('framebuffer', newFramebuffer => {
        framebuffer = newFramebuffer;
        if (framebuffer) {
          screenQuad.material.uniforms.numTextures.value = 2;
          const colorTexture = new THREE.Texture();
          const colorProperties = renderer.properties.get(colorTexture);
          colorProperties.__webglTexture = {
            id: framebuffer.colorTexture,
          };
          colorProperties.__webglInit = true;
          screenQuad.material.uniforms.uTexture2.value = colorTexture;
          const depthTexture = new THREE.Texture();
          const depthProperties = renderer.properties.get(depthTexture);
          depthProperties.__webglTexture = {
            id: framebuffer.depthStencilTexture,
          };
          depthProperties.__webglInit = true;
          screenQuad.material.uniforms.uDepth2.value = depthTexture;
        } else {
          screenQuad.material.uniforms.numTextures.value = 1;
          screenQuad.material.uniforms.uTexture2.value = null;
          screenQuad.material.uniforms.uDepth2.value = null;
        }
      });
      iframe.addEventListener('destroy', () => {
        if (iframeResources) {
          resources.splice(resources.indexOf(iframeResources), 1);
        }
        floorMesh.visible = true;
        skyboxMesh.visible = true;
        scene.background = _makeBackground();
      });
      container.appendChild(iframe);
      return iframe;
    };
    const _closeUrl = iframe => {
      if (iframe.destroy) {
        iframe.destroy();
      }
      container.removeChild(iframe);
    };
    const _updateLocalApps = () => {
      const iframesToKeep = [];
      for (let i = 0; i < iframes.length; i++) {
        const iframe = iframes[i];
        if (currentApps.includes(iframe.src)) {
          iframesToKeep.push(iframe);
        } else {
          _closeUrl(iframe);
          iframes.splice(iframes.indexOf(iframe), 1);
        }
      }
      iframes = iframesToKeep;
    let appsUpdated = false;
      for (let i = 0; i < currentApps.length; i++) {
        const currentApp = currentApps[i];
        if (!iframes.includes(currentApp)) {
          const iframe = _openUrl(currentApp);
          iframes.push(iframe);
        }
        // if (!apps.includes(currentApp)) {
        //   apps.unshift(currentApp);
        //   appsUpdated = true;
        // }
       }
      }

      window.addEventListener('resize', e => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        camera.projectionMatrix.toArray(fakeDisplay._frameData.leftProjectionMatrix);
        camera.projectionMatrix.toArray(fakeDisplay._frameData.rightProjectionMatrix);
        const device = renderer.vr.getDevice();
        if (device === fakeDisplay) {
          renderer.vr.setDevice(null);
          renderer.vr.setAnimationLoop(null);
        }
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        if (device === fakeDisplay) {
          renderer.vr.setDevice(fakeDisplay);
          renderer.vr.setAnimationLoop(animate);
        }
      });
      let displays = [];
      const _updateDisplays = () => {
        Promise.all([
          window.navigator.getVRDisplays ? window.navigator.getVRDisplays() : Promise.resolve([]),
          window.navigator.xr ? window.navigator.xr.requestDevice('VR').then(device => device ? [device] : []) : Promise.resolve([]),
          window.navigator.xr ? window.navigator.xr.requestDevice('AR').then(device => device ? [device] : []) : Promise.resolve([]),
        ])
        .then(ds => {
          displays.length = 0;
          for (let i = 0; i < ds.length; i++) {
            displays.push.apply(displays, ds[i]);
          }
        })
        .catch(err => {
          console.warn(err);
        });
      };
      _updateDisplays();
      window.addEventListener('vrdisplayconnect', _updateDisplays);
      window.addEventListener('vrdisplaydisconnect', _updateDisplays);
      const resources = [];
      const _resourcesUpdate = () => {
        let value = 0;
        let total =  0;
        for (let i = 0; i < resources.length; i++) {
          for (let j = 0; j < resources[i].resources.length; j++) {
            const resource = resources[i].resources[j];
            value += resource.value;
            total += resource.total;
          }
        }
      };
      if (window.document.resources) {
        resources.push(window.document.resources);
      }
      for (let i = 0; i < resources.length; i++) {
        window.document.resources.addEventListener('update', _resourcesUpdate);
      }
      const audioCtx = new AudioContext({
        sampleRate: 48000,
      });
      THREE.AudioContext.setContext(audioCtx);

    var initialTab = 'http://threejs.org/examples/webgl_animation_cloth.html';
      if (initialTab) {
        _submitUrl(initialTab);
      }

  function onWindowResize() {

    // Update camera an renderer aspect and size
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    mrenderer.setSize( window.innerWidth, window.innerHeight );
  }

  function animate() {

    // Render loop.
    requestAnimationFrame( animate );
    //mrenderer.render( scene, camera );
  }
})();

</script>
</body>
</html>
